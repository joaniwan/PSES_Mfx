        -:    0:Source:Mfx.c
        -:    0:Graph:UT_Mfx.gcno
        -:    0:Data:UT_Mfx.gcda
        -:    0:Runs:64
        -:    1:/**===================================================================================================================*\
        -:    2:  @file Mfx.c
        -:    3:
        -:    4:  @brief Bibiloteka Mfx - implementacja
        -:    5:
        -:    6:  @see AUTOSAR_SWS_MFXLibrary.pdf
        -:    7:\*====================================================================================================================*/
        -:    8:
        -:    9:/*====================================================================================================================*\
        -:   10:    Załączenie nagłówków
        -:   11:\*====================================================================================================================*/
        -:   12:#include "Mfx.h"
        -:   13:
        -:   14:/*====================================================================================================================*\
        -:   15:    Makra lokalne
        -:   16:\*====================================================================================================================*/
        -:   17:#define MAX32   (2147483647L)
        -:   18:#define MIN32   (-2147483648L)
        -:   19:
        -:   20:#define UMAX32   (4294967295L)
        -:   21:#define UMIN32   (0L)
        -:   22:
        -:   23:#define MAX16   (32767L)
        -:   24:#define MIN16   (-32768L)
        -:   25:
        -:   26:#define UMAX16   (65535L)
        -:   27:#define UMIN16   (0L)
        -:   28:
        -:   29:#define MAX8  (127L)
        -:   30:#define MIN8   (-128L)
        -:   31:
        -:   32:#define UMAX8  (255L)
        -:   33:#define UMIN8   (0L)
        -:   34:
        -:   35:/*====================================================================================================================*\
        -:   36:    Typy lokalne
        -:   37:\*====================================================================================================================*/
        -:   38:
        -:   39:/*====================================================================================================================*\
        -:   40:    Zmienne globalne
        -:   41:\*====================================================================================================================*/
        -:   42:
        -:   43:/*====================================================================================================================*\
        -:   44:    Zmienne lokalne (statyczne)
        -:   45:\*====================================================================================================================*/
        -:   46:
        -:   47:
        -:   48:/*====================================================================================================================*\
        -:   49:    Deklaracje funkcji lokalnych
        -:   50:\*====================================================================================================================*/
        -:   51:
        -:   52:/*====================================================================================================================*\
        -:   53:    Kod globalnych funkcji inline i makr funkcyjnych
        -:   54:\*====================================================================================================================*/
        -:   55:
        -:   56:/*====================================================================================================================*\
        -:   57:    Kod funkcji
        -:   58:\*====================================================================================================================*/
        -:   59:
        -:   60:/**
        -:   61:  @brief Additions
        -:   62:
        -:   63: This routine makes an addition between the two arguments.
        -:   64:  Project element: [SWS_Mfx_00002] & [SWS_Mfx_00006] & [SWS_Mfx_00007] & [SWS_Mfx_00008 Function ID: 0x00C & 0x014]
        -:   65:*/
        -:   66:
        2:   67:sint16 Mfx_Add_s16s16_s16(sint16 x_value, sint16 y_value)
        -:   68:{
        2:   69:    sint32 tmp = (sint32)x_value + (sint32)y_value;
        -:   70:
        2:   71:    if((tmp>MAX16))
        -:   72:    {
        1:   73:       tmp = MAX16;
        -:   74:    }
        1:   75:    else if((tmp<MIN16))
        -:   76:    {
        1:   77:        tmp = MIN16;
        -:   78:    }
        2:   79:    return (sint16)tmp;
        -:   80:}
        -:   81:
        2:   82:sint32 Mfx_Add_s32s32_s32(sint32 x_value, sint32 y_value)
        -:   83:{
        2:   84:    sint64 tmp = (sint64)x_value + (sint64)y_value;
        -:   85:
        2:   86:    if((tmp>MAX32))
        -:   87:    {
        1:   88:        tmp = MAX32;
        -:   89:    }
        1:   90:    else if ((tmp<MIN32))
        -:   91:    {
        1:   92:        tmp = MIN32;
        -:   93:    }
        2:   94:    return (sint32)tmp;
        -:   95:}
        -:   96:/**
        -:   97:  @brief Substraction
        -:   98:
        -:   99:  This routine makes a subtraction between the two arguments.
        -:  100:  Project element: [SWS_Mfx_00009] & [SWS_Mfx_00010] & [SWS_Mfx_00011] & [SWS_Mfx_00012 Function ID: 0x036 & 0x045]
        -:  101:*/
        2:  102:sint16 Mfx_Sub_s16s16_s16(sint16 x_value, sint16 y_value)
        -:  103:{  
        2:  104:    sint32 tmp = (sint32)x_value - (sint32)y_value;
        -:  105:
        2:  106:    if((tmp>MAX16))
        -:  107:    {
        1:  108:       tmp = MAX16;
        -:  109:    }
        1:  110:    else if((tmp<MIN16))
        -:  111:    {
        1:  112:        tmp = MIN16;
        -:  113:    }
        2:  114:    return (sint16)tmp;
        -:  115:}
        -:  116:
        2:  117:sint32 Mfx_Sub_s32s32_s32(sint32 x_value, sint32 y_value)
        -:  118:{
        2:  119:	sint64 tmp = (sint64)x_value - (sint64)y_value;
        2:  120:    if((tmp>MAX32))
        -:  121:    {
        1:  122:        tmp = MAX32;
        -:  123:    }
        1:  124:    else if ((tmp<MIN32))
        -:  125:    {
        1:  126:        tmp = MIN32;
        -:  127:    }
        2:  128:    return (sint32)tmp;
        -:  129:}
        -:  130:
        -:  131:/**
        -:  132:  @brief Absolute value
        -:  133:
        -:  134:  This routine computes the absolute value of a signed value.
        -:  135:  Project element: [SWS_Mfx_00013] & [SWS_Mfx_00014] & [SWS_Mfx_00015] & [SWS_Mfx_00016 Function ID: 0x059 & 0x05C]
        -:  136:*/
        -:  137:
       24:  138:sint16 Mfx_Abs_s16_s16( sint16 x_value )
        -:  139:{  
       24:  140:    if(x_value==MIN16)
        -:  141:    {
        6:  142:       return MAX16;
        -:  143:    }
        -:  144:    else{
       18:  145:        if(x_value <0)
        -:  146:        {
        5:  147:            return -x_value;
        -:  148:        }
        -:  149:        else
        -:  150:        {
       13:  151:            return x_value;
        -:  152:        }
        -:  153:    }
        -:  154:}
        -:  155:
        -:  156:
       23:  157:sint32 Mfx_Abs_s32_s32( sint32 x_value )
        -:  158:{  
       23:  159:    if(x_value==MIN32)
        -:  160:    {
        5:  161:       return MAX32;
        -:  162:    }
        -:  163:    else{
       18:  164:        if(x_value <0)
        -:  165:        {
        5:  166:            return -x_value;
        -:  167:        }
        -:  168:        else
        -:  169:        {
       13:  170:            return x_value;
        -:  171:        }
        -:  172:    }
        -:  173:}
        -:  174:
        -:  175:
        -:  176:/**
        -:  177:  @brief Absolute value of a difference
        -:  178:
        -:  179:  This routine computes the absolute value of a difference between 2 values.
        -:  180:  Project element: [SWS_Mfx_00017] & [SWS_Mfx_00018] & [SWS_Mfx_00019] & [SWS_Mfx_00020 Function ID:  0x066 & 0x069 & 0x078]
        -:  181:*/
        -:  182:
        5:  183:sint16 Mfx_AbsDiff_s16s16_s16( sint16 x_value, sint16 y_value )
        -:  184:{  
        5:  185:     sint32 tmp = (sint32)x_value - (sint32)y_value;
        -:  186:
        5:  187:    if((tmp>MAX16))
        -:  188:    {
        1:  189:       tmp = MAX16;
        -:  190:    }
        4:  191:    else if((tmp==MIN16))
        -:  192:    {
        1:  193:        tmp = MAX16;
        -:  194:    }
        3:  195:    else if((tmp<MIN16))
        -:  196:    {
        1:  197:        tmp = MIN16;
        -:  198:    }
        -:  199:    else{
        2:  200:        if(tmp <0)
        -:  201:        {
        1:  202:            tmp = -tmp;
        -:  203:        }
        -:  204:        else
        -:  205:        {
        1:  206:            tmp = tmp;
        -:  207:        } 
        -:  208:    }
        5:  209:    return (sint16)tmp;
        -:  210:}
        -:  211:
        -:  212:
        9:  213:sint32 Mfx_AbsDiff_s32s32_s32( sint32 x_value, sint32 y_value )
        -:  214:{  
        9:  215:    sint64 tmp = (sint64)x_value - (sint64)y_value ;
        -:  216:
        9:  217:    if((tmp>MAX32))
        -:  218:    {
        1:  219:       tmp = MAX32;
        -:  220:    }
        8:  221:    else if((tmp==MIN32))
        -:  222:    {
        1:  223:        tmp = MAX32;
        -:  224:    }
        7:  225:    else if((tmp<MIN32))
        -:  226:    {
        1:  227:        tmp = MIN32;
        -:  228:    }
        -:  229:    else{
        6:  230:        if(tmp <0)
        -:  231:        {
        1:  232:            tmp = -tmp;
        -:  233:        }
        -:  234:        else
        -:  235:        {
        5:  236:            tmp = tmp;
        -:  237:        }
        -:  238:    }
        9:  239:    return (sint32)tmp;
        -:  240:}
        -:  241:
        8:  242:uint32 Mfx_AbsDiff_u32u32_u32( uint32 x_value, uint32 y_value )
        -:  243:{  
        8:  244:    sint64 tmp = (uint64)x_value - (uint64)y_value ;
        -:  245:
        8:  246:        if(tmp <0)
        -:  247:        {
        1:  248:            tmp = -tmp;
        -:  249:        }
        7:  250:        else if (tmp >0)
        -:  251:        {
        6:  252:            tmp = tmp;
        -:  253:        }
        -:  254:
        8:  255:     if((tmp>=UMAX32))
        -:  256:    {
        1:  257:       tmp = UMAX32;
        -:  258:    }
        7:  259:    else if((tmp<=UMIN32))
        -:  260:    {
        1:  261:        tmp = UMIN32;
        -:  262:    }
        8:  263:    return (uint32)tmp;
        -:  264:}
        -:  265:/**
        -:  266:  @brief Multiplication
        -:  267:
        -:  268:  This routine makes a multiplication between the two arguments.
        -:  269:  Project element: [SWS_Mfx_00021] & [SWS_Mfx_00022] & [SWS_Mfx_00023] & [SWS_Mfx_00024 Function ID: 0x08A & 0x94]
        -:  270:*/
        -:  271:
       10:  272:sint16 Mfx_Mul_s16s16_s16(sint16 x_value, sint16 y_value)
        -:  273:{
       10:  274:    sint32 tmp = (sint32)x_value * (sint32)y_value;
        -:  275:
       10:  276:    if((tmp>MAX16))
        -:  277:    {
        3:  278:       tmp = MAX16;
        -:  279:    }
        7:  280:    else if((tmp<MIN16))
        -:  281:    {
        1:  282:        tmp = MIN16;
        -:  283:    }
       10:  284:    return (sint16)tmp;
        -:  285:}
        -:  286:
        8:  287:sint32 Mfx_Mul_s32s32_s32(sint32 x_value, sint32 y_value)
        -:  288:{
        8:  289:    sint64 tmp = (sint64)x_value * (sint64)y_value;
        -:  290:
        8:  291:    if((tmp>MAX32))
        -:  292:    {
        2:  293:        tmp = MAX32;
        -:  294:    }
        6:  295:    else if ((tmp<MIN32))
        -:  296:    {
        1:  297:        tmp = MIN32;
        -:  298:    }
        8:  299:    return (sint32)tmp;
        -:  300:}
        -:  301:
        -:  302:/**
        -:  303:  @brief Divisions rounded towards 0
        -:  304:
        -:  305:  These routines make a division between the two arguments.
        -:  306:  Project element: [SWS_Mfx_00025] & [SWS_Mfx_00026] & [SWS_Mfx_00027] & [SWS_Mfx_00028] & [SWS_Mfx_00030] & [SWS_Mfx_00031 Function ID: 0x0B7 & 0x0C3]
        -:  307:*/
        7:  308:sint16 Mfx_Div_s16s16_s16(sint16 x_value, sint16 y_value)
        -:  309:{
        -:  310:	sint32 tmp;
        7:  311:    if(y_value == 0)
        -:  312:	{
        2:  313:		if(x_value >= 0)
        -:  314:		{
        1:  315:			tmp = MAX16;
        -:  316:		}
        -:  317:		else 
        -:  318:		{
        1:  319:			tmp = MIN16;
        -:  320:		}
        -:  321:	}
        -:  322:	else
        -:  323:	{
        5:  324:		tmp = (sint32)x_value/(sint32)y_value;
        -:  325:	}
        7:  326:     if((tmp>=MAX16))
        -:  327:    {
        2:  328:       tmp = MAX16;
        -:  329:    }
        5:  330:    else if((tmp<=MIN16))
        -:  331:    {
        3:  332:        tmp = MIN16;
        -:  333:    }
        7:  334:    return (sint16)tmp;
        -:  335:}
        -:  336:
       10:  337:sint32 Mfx_Div_s32s32_s32(sint32 x_value, sint32 y_value)
        -:  338:{
        -:  339:	sint64 tmp;
       10:  340:    if(y_value == 0)
        -:  341:	{
        2:  342:		if(x_value >= 0)
        -:  343:		{
        1:  344:			tmp = MAX32;
        -:  345:		}
        -:  346:		else 
        -:  347:		{
        1:  348:			tmp = MIN32;
        -:  349:		}
        -:  350:	}
        -:  351:	else
        -:  352:	{
        8:  353:		tmp = (sint64)x_value/(sint64)y_value;
        -:  354:	}
       10:  355:     if((tmp>=MAX32))
        -:  356:    {
        3:  357:       tmp = MAX32;
        -:  358:    }
        7:  359:    else if((tmp<=MIN32))
        -:  360:    {
        3:  361:        tmp = MIN32;
        -:  362:    }
       10:  363:    return (sint32)tmp;
        -:  364:}
        -:  365:
        -:  366:/**
        -:  367:  @brief Divisions rounded off
        -:  368:
        -:  369:  These routines make a division between the two arguments.
        -:  370:  Project element: [SWS_Mfx_00032] & [SWS_Mfx_00033] & [SWS_Mfx_00034] & [SWS_Mfx_00035] & [SWS_Mfx_00037] & [SWS_Mfx_00038 Function ID: 0x0E7 & 0x0F3]
        -:  371:*/
        -:  372:
        8:  373:sint16 Mfx_RDiv_s16s16_s16(sint16 x_value, sint16 y_value)
        -:  374:{
        -:  375:	sint32 tmp;
        8:  376:    if(y_value == 0)
        -:  377:	{
        2:  378:		if(x_value >= 0)
        -:  379:		{
        1:  380:			tmp = MAX16;
        -:  381:		}
        -:  382:		else 
        -:  383:		{
        1:  384:			tmp = MIN16;
        -:  385:		}
        -:  386:	}
        -:  387:	else
        -:  388:	{
        6:  389:        tmp = (sint32)x_value/(sint32)y_value;
        6:  390:        if (Mfx_Abs_s16_s16(x_value)%Mfx_Abs_s16_s16(y_value) == 0 )
        -:  391:		{
        3:  392:            tmp = tmp;
        -:  393:        }
        -:  394:        else
        -:  395:        {
        3:  396:            if((x_value > 0) == (y_value>0))
        -:  397:            {
        2:  398:                tmp = tmp + 1;
        -:  399:            }
        -:  400:            else
        -:  401:            {
        1:  402:                tmp = tmp -1;
        -:  403:            }
        -:  404:        }
        -:  405:	}
        8:  406:     if((tmp>=MAX16))
        -:  407:    {
        2:  408:       tmp = MAX16;
        -:  409:    }
        6:  410:    else if((tmp<=MIN16))
        -:  411:    {
        2:  412:        tmp = MIN16;
        -:  413:    }
        8:  414:    return (sint16)tmp;
        -:  415:}
        -:  416:
        8:  417:sint32 Mfx_RDiv_s32s32_s32(sint32 x_value, sint32 y_value)
        -:  418:{
        -:  419:	sint64 tmp;
        8:  420:    if(y_value == 0)
        -:  421:	{
        2:  422:		if(x_value >= 0)
        -:  423:		{
        1:  424:			tmp = MAX32;
        -:  425:		}
        -:  426:		else 
        -:  427:		{
        1:  428:			tmp = MIN32;
        -:  429:		}
        -:  430:	}
        -:  431:	else
        -:  432:	{
        -:  433:
        6:  434:		tmp = (sint64)x_value/(sint64)y_value;
        6:  435:        if (Mfx_Abs_s32_s32(x_value)%Mfx_Abs_s32_s32(y_value) == 0 )
        -:  436:		{
        3:  437:            tmp = tmp;
        -:  438:        }
        -:  439:        else
        -:  440:        {
        3:  441:            if((x_value > 0) == (y_value>0))
        -:  442:            {
        2:  443:                tmp = tmp + 1;
        -:  444:            }
        -:  445:            else
        -:  446:            {
        1:  447:                tmp = tmp -1;
        -:  448:            }
        -:  449:        }
        -:  450:	}
        8:  451:     if((tmp>=MAX32))
        -:  452:    {
        2:  453:       tmp = MAX32;
        -:  454:    }
        6:  455:    else if((tmp<=MIN32))
        -:  456:    {
        2:  457:        tmp = MIN32;
        -:  458:    }
        8:  459:    return (sint32)tmp;
        -:  460:}
        -:  461:
        -:  462:/**
        -:  463:  @brief Combinations of multiplication and division rounded towards 0
        -:  464:
        -:  465:  These routines make a multiplication between the two arguments and a division by the third argument.
        -:  466:  Project element: [SWS_Mfx_00039] & [SWS_Mfx_00040] & [SWS_Mfx_00041] & [SWS_Mfx_00042] & [SWS_Mfx_00044] & [SWS_Mfx_00045 Function ID: 0x112 & 0x11A]
        -:  467:*/
        1:  468:sint16 Mfx_MulDiv_s16s16_s16(sint16 x_value, sint16 y_value, sint16 z_value)
        -:  469:{
        1:  470:	sint16 tmp = Mfx_Mul_s16s16_s16(x_value,y_value);
        1:  471:    return Mfx_Div_s16s16_s16(tmp,z_value);
        -:  472:}
        -:  473:
        1:  474:sint32 Mfx_MulDiv_s32s32_s32(sint32 x_value, sint32 y_value, sint32 z_value)
        -:  475:{
        1:  476:	sint32 tmp= Mfx_Mul_s32s32_s32(x_value,y_value);
        1:  477:    return Mfx_Div_s32s32_s32(tmp,z_value);
        -:  478:}
        -:  479:
        -:  480:/**
        -:  481:  @brief Combinations of multiplication and division rounded off
        -:  482:
        -:  483:  These routines make a multiplication between the two arguments and a division by the third argument.
        -:  484:  Project element: [SWS_Mfx_00046] & [SWS_Mfx_00047] & [SWS_Mfx_00048] & [SWS_Mfx_00049] & [SWS_Mfx_00051] & [SWS_Mfx_00052 Function ID: 0x129 & 0x134]
        -:  485:*/
        1:  486:sint16 Mfx_RMulDiv_s16s16_s16(sint16 x_value, sint16 y_value, sint16 z_value)
        -:  487:{
        1:  488:	sint16 tmp = Mfx_Mul_s16s16_s16(x_value,y_value);
        1:  489:    return Mfx_RDiv_s16s16_s16(tmp,z_value);
        -:  490:}
        -:  491:
        1:  492:sint32 Mfx_RMulDiv_s32s32_s32(sint32 x_value, sint32 y_value, sint32 z_value)
        -:  493:{
        1:  494:	sint32 tmp= Mfx_Mul_s32s32_s32(x_value,y_value);
        1:  495:    return Mfx_RDiv_s32s32_s32(tmp,z_value);
        -:  496:}
        -:  497:
        -:  498: /**
        -:  499:  @brief Combinations of multiplication and shift right
        -:  500:
        -:  501:  This routine makes a multiplication between the two arguments and applies a shift right defined by the third argument.
        -:  502:  Project element: [SWS_Mfx_00053] & [SWS_Mfx_00054] & [SWS_Mfx_00055] & [SWS_Mfx_00056] & [SWS_Mfx_00057 Function ID: 0x13E & 0x14B]
        -:  503:*/
        4:  504:sint16 Mfx_MulShRight_s16s16u8_s32(sint16 x_value, sint16 y_value, uint8 shift)
        -:  505:{
        4:  506:	sint32 tmp = Mfx_Mul_s16s16_s16(x_value,y_value);
        -:  507:
        4:  508:    if(tmp < 0)
        -:  509:    {
        2:  510:       tmp = Mfx_Abs_s16_s16(tmp);
        2:  511:       if(tmp==MAX16)
        -:  512:       {
        1:  513:             tmp = tmp  >> shift;
        1:  514:             tmp = -tmp-1;
        -:  515:       }
        -:  516:       else
        -:  517:       {
        1:  518:             tmp = tmp  >> shift;
        1:  519:             tmp = -tmp;
        -:  520:       }
        -:  521:    }
        -:  522:    else
        -:  523:    {
        2:  524:        tmp = tmp  >> shift;
        -:  525:    }
        4:  526:    if((tmp>=MAX16))
        -:  527:    {
        1:  528:       tmp = MAX16;
        -:  529:    }
        3:  530:    else if((tmp<=MIN16))
        -:  531:    {
        1:  532:        tmp = MIN16;
        -:  533:    }
        4:  534:    return (sint16)tmp;
        -:  535:}
        -:  536:
        4:  537:sint32 Mfx_MulShRight_s32s32u8_s32(sint32 x_value, sint32 y_value, uint8 shift)
        -:  538:{
        4:  539:	sint64 tmp = Mfx_Mul_s32s32_s32(x_value,y_value);
        -:  540:
        4:  541:    if(tmp < 0)
        -:  542:    {
        2:  543:       tmp = Mfx_Abs_s32_s32(tmp);
        2:  544:       if(tmp==MAX32)
        -:  545:       {
        1:  546:             tmp = tmp  >> shift;
        1:  547:             tmp = -tmp-1;
        -:  548:
        -:  549:       }
        -:  550:       else
        -:  551:       {
        1:  552:            tmp = tmp  >> shift;
        1:  553:            tmp = -tmp;
        -:  554:       }
        -:  555:    }
        -:  556:    else
        -:  557:    {
        2:  558:        tmp = tmp  >> shift;
        -:  559:    }
        4:  560:    if((tmp>=MAX32))
        -:  561:    {
        1:  562:       tmp = MAX32;
        -:  563:    }
        3:  564:    else if((tmp<=MIN32))
        -:  565:    {
        1:  566:        tmp = MIN32;
        -:  567:    }
        4:  568:    return (sint32)tmp;
        -:  569:}
        -:  570:
        -:  571:
        -:  572: /**
        -:  573:  @brief Combinations of division and shift left
        -:  574:
        -:  575:  This routine makes a multiplication between the two arguments and applies a shift right defined by the third argument.
        -:  576:  Project element: [SWS_Mfx_00058] & [SWS_Mfx_00059] & [SWS_Mfx_00060] & [SWS_Mfx_00061] & [SWS_Mfx_00062] & [SWS_Mfx_00064 Function ID: 0x155 & 0x159]
        -:  577:*/
        4:  578:sint16 Mfx_DivShLeft_s16s16u8_s16(sint16 x_value, sint16 y_value, uint8 shift)
        -:  579:{
        -:  580:	sint32 tmp ;
        -:  581:
        4:  582:    if(x_value < 0)
        -:  583:    {
        3:  584:       tmp = Mfx_Abs_s16_s16(x_value);
        3:  585:       if(tmp == MAX16)
        -:  586:       {
        2:  587:            tmp = tmp  << shift;
        2:  588:            tmp = -tmp -1;
        -:  589:       }
        -:  590:       else
        -:  591:       {
        1:  592:           tmp = tmp  << shift;
        1:  593:           tmp = -tmp;
        -:  594:
        -:  595:       }
        -:  596:    }
        -:  597:    else
        -:  598:    {
        1:  599:        tmp = (sint32)x_value  << shift;
        -:  600:    }
        -:  601:
        4:  602:     if((tmp>MAX16))
        -:  603:    {
        1:  604:       tmp = MAX16;
        -:  605:    }
        3:  606:    else if((tmp<MIN16))
        -:  607:    {
        1:  608:        tmp = MIN16;
        -:  609:    }
        -:  610:
        4:  611:    return Mfx_Div_s16s16_s16((sint16)tmp,y_value);
        -:  612:}
        -:  613:
        3:  614:sint32 Mfx_DivShLeft_s32s32u8_s32(sint32 x_value, sint32 y_value, uint8 shift)
        -:  615:{
        -:  616:	sint64 tmp;
        -:  617:
        3:  618:    if(x_value < 0)
        -:  619:    {
        2:  620:       tmp = Mfx_Abs_s32_s32(x_value);
        2:  621:       if(tmp == MAX32)
        -:  622:       {
        1:  623:           tmp = tmp  << shift;
        1:  624:           tmp = -tmp-1;
        -:  625:       }
        -:  626:       else
        -:  627:       {
        1:  628:           tmp = tmp  << shift;
        1:  629:           tmp = -tmp;
        -:  630:       }
        -:  631:       
        -:  632:    }
        -:  633:    else
        -:  634:    {
        1:  635:        tmp = (sint64)x_value  << shift;
        -:  636:    }
        -:  637:
        3:  638:    if((tmp>MAX32))
        -:  639:    {
        1:  640:       tmp = MAX32;
        -:  641:    }
        2:  642:    else if((tmp<MIN32))
        -:  643:    {
        1:  644:        tmp = MIN32;
        -:  645:    }
        3:  646:    return Mfx_Div_s32s32_s32((sint32)tmp,y_value);
        -:  647:}
        -:  648:
        -:  649: /**
        -:  650:  @brief Modulo
        -:  651:
        -:  652:  This routine returns the remainder of the division x_value / y_value if y_value is not zero.
        -:  653:  Project element: [SWS_Mfx_00065] & [SWS_Mfx_00066] & [SWS_Mfx_00068] & [SWS_Mfx_00069] &  [SWS_Mfx_00070 Function ID: 0x172 & 0x174]
        -:  654:*/
        3:  655:sint16 Mfx_Mod_s16(sint16 x_value, sint16 y_value)
        -:  656:{
        -:  657:	sint16 tmp ;
        -:  658:
        3:  659:    if(y_value == 0)
        -:  660:    {
        1:  661:       tmp = 0;
        -:  662:    }
        -:  663:    else
        -:  664:    {
        2:  665:       if(x_value <0)
        -:  666:       {
        1:  667:          tmp = -(x_value%y_value);
        -:  668:       }
        -:  669:       else
        -:  670:       {
        1:  671:           tmp = x_value%y_value;
        -:  672:       }
        -:  673:    }
        -:  674:
        3:  675:    return tmp;
        -:  676:}
        -:  677:
        3:  678:sint32 Mfx_Mod_s32(sint32 x_value, sint32 y_value)
        -:  679:{
        -:  680:	sint32 tmp ;
        -:  681:
        3:  682:    if(y_value == 0)
        -:  683:    {
        1:  684:       tmp = 0;
        -:  685:    }
        -:  686:    else
        -:  687:    {
        2:  688:       if(x_value <0)
        -:  689:       {
        1:  690:          tmp = -(x_value%y_value);
        -:  691:       }
        -:  692:       else
        -:  693:       {
        1:  694:           tmp = x_value%y_value;
        -:  695:       }
        -:  696:    }
        -:  697:
        3:  698:    return tmp;
        -:  699:}
        -:  700:
        -:  701: /**
        -:  702:  @brief Limiting
        -:  703:
        -:  704:  This routine limits the input value between Lower Bound and Upper Bound.
        -:  705:  Project element: [SWS_Mfx_00073] & [SWS_Mfx_00074] & [SWS_Mfx_00075] & [SWS_Mfx_00076] &  [SWS_Mfx_00079 Function ID: 0x17C  & 0x17E ]
        -:  706:*/
        3:  707:sint16 Mfx_Limit_s16(sint16 value, sint16 min_value, sint16 max_value)
        -:  708:{
        -:  709:
        3:  710:    if(value < min_value)
        -:  711:    {
        1:  712:       return min_value;
        -:  713:    }
        2:  714:    else if(value > max_value)
        -:  715:    {
        1:  716:        return max_value;
        -:  717:    }
        -:  718:    else
        -:  719:    {
        1:  720:        return value;
        -:  721:    }
        -:  722:}
        -:  723:
        3:  724:sint32 Mfx_Limit_s32(sint32 value, sint32 min_value, sint32 max_value)
        -:  725:{
        -:  726:
        3:  727:    if(value < min_value)
        -:  728:    {
        1:  729:       return min_value;
        -:  730:    }
        2:  731:    else if(value > max_value)
        -:  732:    {
        1:  733:        return max_value;
        -:  734:    }
        -:  735:    else
        -:  736:    {
        1:  737:        return value;
        -:  738:    }
        -:  739:}
        -:  740:
        -:  741:/**
        -:  742:  @brief Limitations with only one value for minimum and maximum
        -:  743:
        -:  744:  The routine limits a value to a minimum or a maximum that depends on the sign of the minmax_value.
        -:  745:  Project element: [SWS_Mfx_00082] & [SWS_Mfx_00083] & [SWS_Mfx_00084] & [SWS_Mfx_00085] &  [SWS_Mfx_00086 Function ID: 0x182  & 0x184 ]
        -:  746:*/
        3:  747:sint16 Mfx_Minmax_s16(sint16 value, sint16 minmax_value)
        -:  748:{
        3:  749:    if((minmax_value >= 0) && ( value > minmax_value ))
        -:  750:    {
        1:  751:        return minmax_value;
        -:  752:    }
        2:  753:    else if((minmax_value < 0) && (value < minmax_value))
        -:  754:    {
        1:  755:        return minmax_value;
        -:  756:    }
        -:  757:    else
        -:  758:    {
        1:  759:        return value;
        -:  760:    }
        -:  761:}
        -:  762:
        3:  763:sint32 Mfx_Minmax_s32(sint32 value, sint32 minmax_value)
        -:  764:{
        3:  765:    if((minmax_value >= 0) && ( value > minmax_value ))
        -:  766:    {
        1:  767:        return minmax_value;
        -:  768:
        -:  769:    }
        2:  770:    else if((minmax_value < 0) && (value < minmax_value))
        -:  771:    {
        1:  772:        return minmax_value;
        -:  773:    }
        -:  774:    else
        -:  775:    {
        1:  776:        return value;
        -:  777:    }
        -:  778:}
        -:  779:
        -:  780:/**
        -:  781:  @brief Minimum and maximum
        -:  782:
        -:  783:  TThis routine returns the minimum between two values.
        -:  784:  Project element: [SWS_Mfx_00082] & [SWS_Mfx_00090] & [SWS_Mfx_00091] & [SWS_Mfx_00092] & [SWS_Mfx_00093] & [SWS_Mfx_00094] & [SWS_Mfx_00095] &  [SWS_Mfx_00096 Function ID: 0x188  & 0x18A & 0x18E & 0x190]
        -:  785:*/
        2:  786:sint16 Mfx_Min_s16(sint16 x_value, sint16 y_value)
        -:  787:{
        2:  788:    if(x_value<y_value)
        -:  789:    {
        1:  790:        return x_value;
        -:  791:    }
        -:  792:    else 
        -:  793:    {
        1:  794:        return y_value;
        -:  795:    }
        -:  796:}
        -:  797:
        2:  798:sint32 Mfx_Min_s32(sint32 x_value, sint32 y_value)
        -:  799:{
        2:  800:    if(x_value<y_value)
        -:  801:    {
        1:  802:        return x_value;
        -:  803:    }
        -:  804:    else 
        -:  805:    {
        1:  806:        return y_value;
        -:  807:    } 
        -:  808:}
        -:  809:
        2:  810:sint16 Mfx_Max_s16(sint16 x_value, sint16 y_value)
        -:  811:{
        2:  812:    if(x_value>y_value)
        -:  813:    {
        1:  814:        return x_value;
        -:  815:    }
        -:  816:    else 
        -:  817:    {
        1:  818:        return y_value;
        -:  819:    }
        -:  820:}
        -:  821:
        2:  822:sint32 Mfx_Max_s32(sint32 x_value, sint32 y_value)
        -:  823:{
        2:  824:    if(x_value>y_value)
        -:  825:    {
        1:  826:        return x_value;
        -:  827:    }
        -:  828:    else 
        -:  829:    {
        1:  830:        return y_value;
        -:  831:    } 
        -:  832:}
        -:  833:
        -:  834:/**
        -:  835:  @brief 16-Bit to 8-Bit 2n Scaled Integer Conversion
        -:  836:The routine converts a scaled 16-bit integer to a scaled 8-bit integer.
        -:  837:  Project element: [SWS_Mfx_00100] & [SWS_Mfx_00101] & [SWS_Mfx_00102] & [SWS_Mfx_00103] &  [SWS_Mfx_00104 Function ID: 0x191  & 0x192]
        -:  838:*/
        4:  839:sint8 Mfx_ConvertP2_s16_s8(sint16 x, sint16 a, sint16 c)
        -:  840:{
        -:  841:    sint16 tmp;
        -:  842:
        4:  843:        if((c-a)<-15)
        -:  844:        {
        1:  845:          tmp = MIN8;
        -:  846:        }
        3:  847:        else if((c-a)>7)
        -:  848:        {
        1:  849:          tmp = MAX8;
        -:  850:        }
        -:  851:        else
        -:  852:        {
        2:  853:            if(c>=a)
        -:  854:            {
        1:  855:                tmp = (x << (c-a));
        -:  856:            }
        -:  857:            else
        -:  858:            {
        1:  859:                tmp = (x >> (a-c));
        -:  860:            }
        -:  861:        }
        -:  862:
        4:  863:        if(tmp >= MAX8)
        -:  864:        {
        1:  865:            tmp = MAX8;
        -:  866:        }
        3:  867:        else if (tmp <= MIN8)
        -:  868:        {
        1:  869:            tmp = MIN8;
        -:  870:        }
        4:  871:        return (sint8)tmp;
        -:  872:}
        -:  873:
        4:  874:uint8 Mfx_ConvertP2_u16_u8(uint16 x, sint16 a, sint16 c)
        -:  875:{
        -:  876:    uint16 tmp;
        -:  877:
        4:  878:        if((c-a)<-15)
        -:  879:        {
        1:  880:          tmp = UMIN8;
        -:  881:        }
        3:  882:        else if((c-a)>7)
        -:  883:        {
        1:  884:          tmp = UMAX8;
        -:  885:        }
        -:  886:        else
        -:  887:        {
        2:  888:            if(c>=a)
        -:  889:            {
        1:  890:                tmp = (x << (c-a));
        -:  891:            }
        -:  892:            else
        -:  893:            {
        1:  894:                tmp = (x >> (a-c));
        -:  895:            }
        -:  896:        }
        -:  897:
        4:  898:        if(tmp >= UMAX8)
        -:  899:        {
        1:  900:            tmp = UMAX8;
        -:  901:        }
        3:  902:        else if (tmp <= UMIN8)
        -:  903:        {
        2:  904:            tmp = UMIN8;
        -:  905:        }
        4:  906:        return (uint8)tmp;
        -:  907:}
        -:  908:
        -:  909:
        -:  910:/**
        -:  911:  @brief 8-Bit to 16-Bit 2n Scaled Integer Conversion
        -:  912:
        -:  913:  The routine converts a scaled 8-bit integer to a scaled 16-bit integer.
        -:  914:  Project element: [SWS_Mfx_00106] & [SWS_Mfx_00107] & [SWS_Mfx_00108] & [SWS_Mfx_00109] &  [SWS_Mfx_00110 Function ID: 0x193  & 0x194]
        -:  915:*/
        4:  916:sint16 Mfx_ConvertP2_s8_s16 (sint8 x, sint16 a, sint16 c){
        -:  917:    sint32 tmp;
        -:  918:
        -:  919:        if((c-a)<-7)
        4:  920:        {
        -:  921:          tmp = MIN16;
        1:  922:        }
        -:  923:        else if((c-a)>15)
        3:  924:        {
        -:  925:          tmp = MAX16;
        1:  926:        }
        -:  927:        else
        -:  928:        {
        -:  929:            if(c>=a)
        2:  930:            {
        -:  931:                tmp = (x << (c-a));
        1:  932:            }
        -:  933:            else
        -:  934:            {
        -:  935:                tmp = (x >> (a-c));
        1:  936:            }
        -:  937:        }
        -:  938:
        -:  939:        if(tmp >= MAX16)
        4:  940:        {
        -:  941:            tmp = MAX16;
        1:  942:        }
        -:  943:        else if (tmp <= MIN16)
        3:  944:        {
        -:  945:            tmp = MIN16;
        1:  946:        }
        -:  947:        return (sint16)tmp;
        4:  948:}
        -:  949:
        -:  950:uint16 Mfx_ConvertP2_u8_u16(uint8 x, sint16 a, sint16 c)
        4:  951:{
        -:  952:    uint32 tmp;
        -:  953:
        -:  954:        if((c-a)<-7)
        4:  955:        {
        -:  956:          tmp = UMIN16;
        1:  957:        }
        -:  958:        else if((c-a)>15)
        3:  959:        {
        -:  960:          tmp = UMAX16;
        1:  961:        }
        -:  962:        else
        -:  963:        {
        -:  964:            if(c>=a)
        2:  965:            {
        -:  966:                tmp = (x << (c-a));
        1:  967:            }
        -:  968:            else
        -:  969:            {
        -:  970:                tmp = (x >> (a-c));
        1:  971:            }
        -:  972:        }
        -:  973:
        -:  974:        if(tmp >= UMAX16)
        4:  975:        {
        -:  976:            tmp = UMAX16;
        1:  977:        }
        -:  978:        else if (tmp <= UMIN16)
        3:  979:        {
        -:  980:            tmp = UMIN16;
        2:  981:        }
        -:  982:        return (uint16)tmp;
        4:  983:}
        -:  984:
        -:  985:
        -:  986:/**
        -:  987:  @brief 32-Bit to 16-Bit 2n Scaled Integer Conversion
        -:  988:
        -:  989: The routine converts a scaled 32-bit integer to a scaled 16-bit integer
        -:  990:  Project element: [SWS_Mfx_00112] & [SWS_Mfx_00113] & [SWS_Mfx_00114] & [SWS_Mfx_00115] &  [SWS_Mfx_00116 Function ID: 0x195  & 0x196]
        -:  991:*/
        -:  992:sint16 Mfx_ConvertP2_s32_s16 (sint32 x, sint16 a, sint16 c){
        4:  993:    sint32 tmp;
        -:  994:
        -:  995:        if((c-a)<-31)
        -:  996:        {
        4:  997:          tmp = MIN16;
        -:  998:        }
        1:  999:        else if((c-a)>15)
        -: 1000:        {
        3: 1001:          tmp = MAX16;
        -: 1002:        }
        1: 1003:        else
        -: 1004:        {
        -: 1005:            if(c>=a)
        -: 1006:            {
        2: 1007:                tmp = (x << (c-a));
        -: 1008:            }
        1: 1009:            else
        -: 1010:            {
        -: 1011:                tmp = (x >> (a-c));
        -: 1012:            }
        1: 1013:        }
        -: 1014:
        -: 1015:        if(tmp >= MAX16)
        -: 1016:        {
        4: 1017:            tmp = MAX16;
        -: 1018:        }
        1: 1019:        else if (tmp <= MIN16)
        -: 1020:        {
        3: 1021:            tmp = MIN16;
        -: 1022:        }
        1: 1023:        return (sint16)tmp;
        -: 1024:}
        4: 1025:
        -: 1026:uint16 Mfx_ConvertP2_u32_u16 (uint32 x, sint16 a, sint16 c)
        -: 1027:{
        4: 1028:    uint32 tmp;
        -: 1029:
        -: 1030:        if((c-a)<-31)
        -: 1031:        {
        4: 1032:          tmp = UMIN16;
        -: 1033:        }
        1: 1034:        else if((c-a)>15)
        -: 1035:        {
        3: 1036:          tmp = UMAX16;
        -: 1037:        }
        1: 1038:        else
        -: 1039:        {
        -: 1040:            if(c>=a)
        -: 1041:            {
        2: 1042:                tmp = (x << (c-a));
        -: 1043:            }
        1: 1044:            else
        -: 1045:            {
        -: 1046:                tmp = (x >> (a-c));
        -: 1047:            }
        1: 1048:        }
        -: 1049:
        -: 1050:        if(tmp >= UMAX16)
        -: 1051:        {
        4: 1052:            tmp = UMAX16;
        -: 1053:        }
        1: 1054:        else if (tmp <= UMIN16)
        -: 1055:        {
        3: 1056:            tmp = UMIN16;
        -: 1057:        }
        2: 1058:        return (uint16)tmp;
        -: 1059:}
        4: 1060:
        -: 1061:
        -: 1062:/**
        -: 1063:  @brief 16-Bit to 32-Bit 2n Scaled Integer Conversion
        -: 1064:
        -: 1065: The routine converts a scaled 16-bit integer to a scaled 32-bit integer
        -: 1066:  Project element: [SWS_Mfx_00118] & [SWS_Mfx_00119] & [SWS_Mfx_00120] & [SWS_Mfx_00121] &  [SWS_Mfx_00122 Function ID: 0x197  & 0x198]
        -: 1067:*/
        -: 1068:
        -: 1069:sint32 Mfx_ConvertP2_s16_s32(sint16 x, sint16 a, sint16 c)
        -: 1070:{
        4: 1071:    sint64 tmp;
        -: 1072:    if ((c - a) < -15)
        -: 1073:    {
        4: 1074:        tmp = MIN32;
        -: 1075:    }
        1: 1076:    else if ((c - a) > 31)
        -: 1077:    {
        3: 1078:        tmp = MAX32;
        -: 1079:    }
        1: 1080:    else
        -: 1081:    {
        -: 1082:        if (c >= a)
        -: 1083:        {
        2: 1084:            tmp = (x << (c - a));
        -: 1085:        }
        1: 1086:        else
        -: 1087:        {
        -: 1088:            tmp = (x >> (a - c));
        -: 1089:        }
        1: 1090:    }
        -: 1091:
        -: 1092:
        -: 1093:    if (tmp >= MAX32)
        -: 1094:    {
        4: 1095:        tmp = MAX32;
        -: 1096:    }
        1: 1097:    else if (tmp <= MIN32)
        -: 1098:    {
        3: 1099:        tmp = MIN32;
        -: 1100:    }
        1: 1101:        return (sint32)tmp;
        -: 1102:    }
        4: 1103:
        -: 1104:
        -: 1105:
        -: 1106:uint32 Mfx_ConvertP2_u16_u32(uint16 x, sint16 a, sint16 c)
        -: 1107:{
        4: 1108:    uint64 tmp;
        -: 1109:    if ((c - a) < -15)
        -: 1110:    {
        4: 1111:        tmp = UMIN32;
        -: 1112:    }
        1: 1113:    else if ((c - a) > 31)
        -: 1114:    {
        3: 1115:        tmp = UMAX32;
        -: 1116:    }
        1: 1117:    else
        -: 1118:    {
        -: 1119:        if (c >= a)
        -: 1120:        {
        2: 1121:            tmp = (x << (c - a));
        -: 1122:        }
        1: 1123:        else
        -: 1124:        {
        -: 1125:            tmp = (x >> (a - c));
        -: 1126:        }
        1: 1127:    }
        -: 1128:
        -: 1129:
        -: 1130:
        -: 1131:    if (tmp >= UMAX32)
        -: 1132:    {
        4: 1133:        tmp = UMAX32;
        -: 1134:    }
        1: 1135:    else if (tmp <= UMIN32)
        -: 1136:    {
        3: 1137:        tmp = UMIN32;
        -: 1138:    }
        2: 1139:        return (uint32)tmp;
        -: 1140:}
        4: 1141:
        -: 1142:/**
        -: 1143:  @brief 16-Bit Multiplication of 2n Scaled Integer
        -: 1144:
        -: 1145:The routine multiplies two 16-bit integers with scaling factors set by input parameters.
        -: 1146:  Project element: [SWS_Mfx_00124] & [SWS_Mfx_00125] & [SWS_Mfx_00126] & [SWS_Mfx_00127] &  [SWS_Mfx_00128 Function ID: 0x199  & 0x19E]
        -: 1147:*/
        -: 1148:
        -: 1149:
        -: 1150:sint16 Mfx_MulP2_s16s16_s16(sint16 x, sint16 y, sint16 a,sint16 b, sint16 c){
        -: 1151:    sint32 tmp;
        4: 1152:
        -: 1153:        if((c-b-a)<-31)
        -: 1154:        {
        -: 1155:          tmp = MIN16;
        4: 1156:        }
        -: 1157:        else if((c-b-a)>15)
        1: 1158:        {
        -: 1159:          tmp = MAX16;
        3: 1160:        }
        -: 1161:        else
        1: 1162:        {
        -: 1163:            tmp = (1 <<(a-b))* (sint32)x*(sint32)y;
        -: 1164:            if(c-a>=0)
        -: 1165:            {
        2: 1166:                tmp = (tmp << (c-a));
        2: 1167:            }
        -: 1168:            else
        1: 1169:            {
        -: 1170:                tmp = (tmp >> (a-c));
        -: 1171:            }
        -: 1172:        }
        1: 1173:
        -: 1174:        if(tmp >= MAX16)
        -: 1175:        {
        -: 1176:            tmp = MAX16;
        4: 1177:        }
        -: 1178:        else if (tmp <= MIN16)
        1: 1179:        {
        -: 1180:            tmp = MIN16;
        3: 1181:        }
        -: 1182:        return (sint16)tmp;
        1: 1183:}
        -: 1184:
        4: 1185:uint16 Mfx_MulP2_u16u16_u16(uint16 x, uint16 y, sint16 a,sint16 b, sint16 c){
        -: 1186:    sint32 tmp;
        -: 1187:
        4: 1188:        if((c-b-a)<-31)
        -: 1189:        {
        -: 1190:          tmp = UMIN16;
        -: 1191:        }
        4: 1192:        else if((c-b-a)>15)
        -: 1193:        {
        1: 1194:          tmp = UMAX16;
        -: 1195:        }
        3: 1196:        else
        -: 1197:        {
        1: 1198:            tmp = (1 <<(a-b))* (sint32)x*(sint32)y;
        -: 1199:            if(c-a>=0)
        -: 1200:            {
        -: 1201:                tmp = (tmp << (c-a));
        2: 1202:            }
        2: 1203:            else
        -: 1204:            {
        1: 1205:                tmp = (tmp >> (a-c));
        -: 1206:            }
        -: 1207:        }
        -: 1208:
        1: 1209:        if(tmp >= UMAX16)
        -: 1210:        {
        -: 1211:            tmp = UMAX16;
        -: 1212:        }
        4: 1213:        else if (tmp <= UMIN16)
        -: 1214:        {
        1: 1215:            tmp = UMIN16;
        -: 1216:        }
        3: 1217:        return (uint16)tmp;
        -: 1218:}
        1: 1219:
        -: 1220:/**
        4: 1221:  @brief 32-Bit Multiplication of 2n Scaled Integer
        -: 1222:
        -: 1223:The routine multiplies two 32-bit integers with scaling factors set by input parameters.
        -: 1224:  Project element: [SWS_Mfx_00130] & [SWS_Mfx_00131] & [SWS_Mfx_00132] & [SWS_Mfx_00133] &  [SWS_Mfx_00134 Function ID: 0x19F  & 0x1A4 ]
        -: 1225:*/
        -: 1226:
        -: 1227:
        -: 1228:sint32 Mfx_MulP2_s32s32_s32(sint32 x, sint32 y, sint16 a, sint16 b, sint16 c)
        -: 1229:{
        -: 1230:    sint64 tmp;
        -: 1231:
        4: 1232:        if((c-b-a)<-63)
        -: 1233:        {
        -: 1234:          tmp = MIN32;
        -: 1235:        }
        4: 1236:        else if((c-b-a)>31)
        -: 1237:        {
        1: 1238:          tmp = MAX32;
        -: 1239:        }
        3: 1240:        else
        -: 1241:        {
        1: 1242:            tmp = (1 <<(a-b))* (sint32)x*(sint32)y;
        -: 1243:            if(c-a>=0)
        -: 1244:            {
        -: 1245:                tmp = (tmp << (c-a));
        2: 1246:            }
        2: 1247:            else
        -: 1248:            {
        1: 1249:                tmp = (tmp >> (a-c));
        -: 1250:            }
        -: 1251:        }
        -: 1252:
        1: 1253:        if(tmp >= MAX32)
        -: 1254:        {
        -: 1255:            tmp = MAX32;
        -: 1256:        }
        4: 1257:        else if (tmp <= MIN32)
        -: 1258:        {
        1: 1259:            tmp = MIN32;
        -: 1260:        }
        3: 1261:        return (sint32)tmp;
        -: 1262:}
        1: 1263:
        -: 1264:uint32 Mfx_MulP2_u32u32_u32(uint32 x, uint32 y, sint16 a, sint16 b, sint16 c){
        4: 1265:    sint64 tmp;
        -: 1266:
        -: 1267:        if((c-b-a)<-63)
        4: 1268:        {
        -: 1269:          tmp = UMIN32;
        -: 1270:        }
        -: 1271:        else if((c-b-a)>31)
        4: 1272:        {
        -: 1273:          tmp = UMAX32;
        1: 1274:        }
        -: 1275:        else
        3: 1276:        {
        -: 1277:            tmp = (1 <<(a-b))* (sint32)x*(sint32)y;
        1: 1278:            if(c-a>=0)
        -: 1279:            {
        -: 1280:                tmp = (tmp << (c-a));
        -: 1281:            }
        2: 1282:            else
        2: 1283:            {
        -: 1284:                tmp = (tmp >> (a-c));
        1: 1285:            }
        -: 1286:        }
        -: 1287:
        -: 1288:        if(tmp >= UMAX32)
        1: 1289:        {
        -: 1290:            tmp = UMAX32;
        -: 1291:        }
        -: 1292:        else if (tmp <= UMIN32)
        4: 1293:        {
        -: 1294:            tmp = UMIN32;
        1: 1295:        }
        -: 1296:        return (uint32)tmp;
        3: 1297:}
        -: 1298:
        1: 1299:
        -: 1300:/**
        4: 1301:  @brief 16-Bit Division of 2n Scaled Integer
        -: 1302:The routine divides two 16-bit integers with scaling factors set by input parameters.
        -: 1303:  Project element: [SWS_Mfx_00136] & [SWS_Mfx_00137] & [SWS_Mfx_00138] & [SWS_Mfx_00139] & [SWS_Mfx_00141] &  [SWS_Mfx_00142 Function ID: 0x1A5  & 0x1AC ]
        -: 1304:*/
        -: 1305:
        -: 1306:
        -: 1307:sint16 Mfx_DivP2_s16s16_s16(sint16 x, sint16 y, sint16 a, sint16 b, sint16 c)
        -: 1308:{
        -: 1309:    sint32 tmp;
        -: 1310:
        -: 1311:        if((c+b-a)<-15)
        4: 1312:        {
        -: 1313:          tmp = MIN16;
        -: 1314:        }
        -: 1315:        else if((c+b-a)>31)
        4: 1316:        {
        -: 1317:          tmp = MAX16;
        1: 1318:        }
        -: 1319:        else
        3: 1320:        {
        -: 1321:            tmp = ((1 << (a+b)) * (sint32)x);
        1: 1322:            tmp = Mfx_Div_s32s32_s32(tmp, (sint32)y);
        -: 1323:            if(c-a>=0)
        -: 1324:            {
        -: 1325:                tmp = (tmp << (c-a));
        2: 1326:            }
        2: 1327:            else
        2: 1328:            {
        -: 1329:                tmp = (tmp >> (a-c));
        1: 1330:            }
        -: 1331:        }
        -: 1332:
        -: 1333:        if(tmp >= MAX16)
        1: 1334:        {
        -: 1335:            tmp = MAX16;
        -: 1336:        }
        -: 1337:        else if (tmp <= MIN16)
        4: 1338:        {
        -: 1339:            tmp = MIN16;
        1: 1340:        }
        -: 1341:        return (sint16)tmp;
        3: 1342:}
        -: 1343:
        1: 1344:uint16 Mfx_DivP2_u16u16_u16(uint16 x, uint16 y, sint16 a,sint16 b, sint16 c){
        -: 1345:    sint32 tmp;
        4: 1346:
        -: 1347:        if((c+b-a)<-15)
        -: 1348:        {
        5: 1349:          tmp = UMIN16;
        -: 1350:        }
        -: 1351:        else if((c+b-a)>31)
        -: 1352:        {
        5: 1353:          tmp = UMAX16;
        -: 1354:        }
        1: 1355:        else
        -: 1356:        {
        4: 1357:            if(y==0 && x>=0)
        -: 1358:            {
        1: 1359:                tmp = UMAX16;
        -: 1360:            }
        -: 1361:            else if( y == 0 && x<0)
        -: 1362:            {
        3: 1363:                tmp = UMIN16;
        -: 1364:            }
        1: 1365:            else
        -: 1366:            {
        -: 1367:                tmp = (((1 << (a+b)) * (sint32)x)/(sint32)y);
        -: 1368:            }
        -: 1369:            if(c-a>=0)
        -: 1370:            {
        -: 1371:                tmp = (tmp << (c-a));
        -: 1372:            }
        2: 1373:            else
        -: 1374:            {
        3: 1375:                tmp = (tmp >> (a-c));
        -: 1376:            }
        2: 1377:        }
        -: 1378:
        -: 1379:        if(tmp >= UMAX16)
        -: 1380:        {
        1: 1381:            tmp = UMAX16;
        -: 1382:        }
        -: 1383:        else if (tmp <= UMIN16)
        -: 1384:        {
        5: 1385:            tmp = UMIN16;
        -: 1386:        }
        2: 1387:        return (uint16)tmp;
        -: 1388:}
        3: 1389:
        -: 1390:
        1: 1391:/**
        -: 1392:  @brief 32-Bit Division of 2n Scaled Integer
        5: 1393:The routine divides two 32-bit integers with scaling factors set by input parameters.
        -: 1394:  Project element: [SWS_Mfx_00144] & [SWS_Mfx_00145] & [SWS_Mfx_00146] & [SWS_Mfx_00147] & [SWS_Mfx_00149] &  [SWS_Mfx_00150 Function ID: 0x1AD  & 0x1B4 ]
        -: 1395:*/
        -: 1396:
        -: 1397:sint32 Mfx_DivP2_s32s32_s32(sint32 x, sint32 y, sint16 a,sint16 b, sint16 c)
        -: 1398:{
        -: 1399:    sint64 tmp;
        -: 1400:
        -: 1401:        if((c+b-a)<-31)
        -: 1402:        {
        6: 1403:          tmp = MIN32;
        -: 1404:        }
        -: 1405:        else if((c+b-a)>63)
        -: 1406:        {
        6: 1407:          tmp = MAX32;
        -: 1408:        }
        1: 1409:        else
        -: 1410:        {
        5: 1411:            if(y==0 && x>=0)
        -: 1412:            {
        1: 1413:                tmp = MAX32;
        -: 1414:            }
        -: 1415:            else if( y == 0 && x<0)
        -: 1416:            {
        4: 1417:                tmp = MIN32;
        -: 1418:            }
        1: 1419:            else
        -: 1420:            {
        3: 1421:                tmp = (((1 << (a+b)) * (sint64)x)/(sint64)y);
        -: 1422:            }
        1: 1423:            if(c-a>=0)
        -: 1424:            {
        -: 1425:                tmp = (tmp << (c-a));
        -: 1426:            }
        2: 1427:            else
        -: 1428:            {
        4: 1429:                tmp = (tmp >> (a-c));
        -: 1430:            }
        3: 1431:        }
        -: 1432:
        -: 1433:        if(tmp >= MAX32)
        -: 1434:        {
        1: 1435:            tmp = MAX32;
        -: 1436:        }
        -: 1437:        else if (tmp <= MIN32)
        -: 1438:        {
        6: 1439:            tmp = MIN32;
        -: 1440:        }
        2: 1441:        return (sint32)tmp;
        -: 1442:}
        4: 1443:
        -: 1444:uint32 Mfx_DivP2_u32u32_u32(uint32 x, uint32 y, sint16 a,sint16 b, sint16 c){
        2: 1445:    sint64 tmp;
        -: 1446:
        6: 1447:        if((c+b-a)<-31)
        -: 1448:        {
        -: 1449:          tmp = UMIN32;
        5: 1450:        }
        -: 1451:        else if((c+b-a)>63)
        -: 1452:        {
        -: 1453:          tmp = UMAX32;
        5: 1454:        }
        -: 1455:        else
        1: 1456:        {
        -: 1457:            if(y==0 && x>=0)
        4: 1458:            {
        -: 1459:                tmp = UMAX32;
        1: 1460:            }
        -: 1461:            else
        -: 1462:            {
        -: 1463:                tmp = (((1 << (a+b)) * (sint64)x)/(sint64)y);
        3: 1464:            }
        -: 1465:            if(c-a>=0)
        1: 1466:            {
        -: 1467:                tmp = (tmp << (c-a));
        -: 1468:            }
        -: 1469:            else
        2: 1470:            {
        -: 1471:                tmp = (tmp >> (a-c));
        3: 1472:            }
        -: 1473:        }
        2: 1474:
        -: 1475:        if(tmp >= UMAX32)
        -: 1476:        {
        -: 1477:            tmp = UMAX32;
        1: 1478:        }
        -: 1479:        else if (tmp <= UMIN32)
        -: 1480:        {
        -: 1481:            tmp = UMIN32;
        5: 1482:        }
        -: 1483:        return (uint32)tmp;
        2: 1484:}
        -: 1485:
        3: 1486:
        -: 1487:/**
        1: 1488:  @brief 16-Bit Addition of 2n Scaled Integer
        -: 1489:The routine adds two 16-bit integers with scaling factors set by input parameters
        5: 1490:  Project element: [SWS_Mfx_00152] & [SWS_Mfx_00153] & [SWS_Mfx_00154] & [SWS_Mfx_00155] &  [SWS_Mfx_00156 Function ID: 0x1B5  & 0x1BA ]
        -: 1491:*/
        -: 1492:
        -: 1493:sint16 Mfx_AddP2_s16s16_s16(sint16 x, sint16 y, sint16 a, sint16 b, sint16 c)
        -: 1494:{
        -: 1495:    sint32 tmp;
        -: 1496:    if(a>=b)
        -: 1497:    {
        -: 1498:        if(((a-b)>15) || ((c-b)>15) || ((a-c)>15))
        -: 1499:        {
        7: 1500:          tmp = MAX16;
        -: 1501:        }
        -: 1502:        else
        7: 1503:        {
        -: 1504:            tmp = (1 << (a-b)) * y + x;
        4: 1505:            if(c>=a)
        -: 1506:            {
        1: 1507:                tmp = (tmp << (c-a));
        -: 1508:            }
        -: 1509:            else
        -: 1510:            {
        3: 1511:                tmp = (tmp >> (a-c));
        3: 1512:            }
        -: 1513:        }
        1: 1514:    }
        -: 1515:    else
        -: 1516:    {
        -: 1517:        if(((b-a)>15) || ((c-a)>15) || ((b-c)>15))
        2: 1518:        {
        -: 1519:          tmp = MAX16;
        -: 1520:        }
        -: 1521:        else
        -: 1522:        {
        -: 1523:            tmp = (1 << (b-a)) * x + y;
        3: 1524:            if(c>=b)
        -: 1525:            {
        1: 1526:               tmp = (tmp << (c-b));
        -: 1527:            }
        -: 1528:            else
        -: 1529:            {
        2: 1530:                tmp = (tmp >> (b-c));
        2: 1531:            }
        -: 1532:        }
        1: 1533:    }
        -: 1534:
        -: 1535:    
        -: 1536:    if(tmp >= MAX16)
        1: 1537:        {
        -: 1538:            tmp = MAX16;
        -: 1539:        }
        -: 1540:        else if (tmp <= MIN16)
        -: 1541:        {
        -: 1542:            tmp = MIN16;
        7: 1543:        }
        -: 1544:        return (sint16)tmp;
        2: 1545:}
        -: 1546:uint16 Mfx_AddP2_u16u16_u16(uint16 x, uint16 y, sint16 a, sint16 b, sint16 c)
        5: 1547:{
        -: 1548:    uint32 tmp;
        1: 1549:    if(a>=b)
        -: 1550:    {
        7: 1551:        if(((a-b)>15) || ((c-b)>15) || ((a-c)>15))
        -: 1552:        {
        -: 1553:          tmp = UMAX16;
        7: 1554:        }
        -: 1555:        else
        -: 1556:        {
        7: 1557:            tmp = (1 << (a-b)) * y + x;
        -: 1558:            if(c>=a)
        4: 1559:            {
        -: 1560:               tmp= (tmp << (c-a));
        1: 1561:            }
        -: 1562:            else
        -: 1563:            {
        -: 1564:                tmp = (tmp >> (a-c));
        3: 1565:            }
        3: 1566:        }
        -: 1567:    }
        1: 1568:    else
        -: 1569:    {
        -: 1570:        if(((b-a)>15) || ((c-a)>15) || ((b-c)>15))
        -: 1571:        {
        2: 1572:          tmp =  UMAX16;
        -: 1573:        }
        -: 1574:        else
        -: 1575:        {
        -: 1576:            tmp = (1 << (b-a)) * x + y;
        -: 1577:            if(c>=b)
        3: 1578:            {
        -: 1579:                tmp = (tmp << (c-b));
        1: 1580:            }
        -: 1581:            else
        -: 1582:            {
        -: 1583:                tmp = (tmp >> (b-c));
        2: 1584:            }
        2: 1585:        }
        -: 1586:    }
        1: 1587:
        -: 1588:
        -: 1589:    if(tmp >= UMAX16)
        -: 1590:        {
        1: 1591:            tmp = UMAX16;
        -: 1592:        }
        -: 1593:        else if (tmp <= UMIN16)
        -: 1594:        {
        -: 1595:            tmp = UMIN16;
        -: 1596:        }
        7: 1597:        return (uint16)tmp;
        -: 1598:
        2: 1599:}
        -: 1600:
        5: 1601:
        -: 1602:
        1: 1603:/**
        -: 1604:  @brief 32-Bit Addition of 2n Scaled Integer
        7: 1605:The routine adds two 32-bit integers with scaling factors set by input parameters
        -: 1606:  Project element: [SWS_Mfx_00158] & [SWS_Mfx_00159] & [SWS_Mfx_00160] & [SWS_Mfx_00161] &  [SWS_Mfx_00162 Function ID: 0x1BB  & 0x1C0 ]
        -: 1607:*/
        -: 1608:
        -: 1609:sint32 Mfx_AddP2_s32s32_s32(sint32 x, sint32 y, sint32 a, sint32 b, sint32 c)
        -: 1610:{
        -: 1611:    sint64 tmp;
        -: 1612:    if(a>=b)
        -: 1613:    {
        -: 1614:        if(((a-b)>31) || ((c-b)>31) || ((a-c)>31))
        -: 1615:        {
        -: 1616:          tmp = MAX32;
        7: 1617:        }
        -: 1618:        else
        -: 1619:        {
        7: 1620:            tmp = (1 << (a-b)) * y + x;
        -: 1621:            if(c>=a)
        3: 1622:            {
        -: 1623:                tmp = (tmp << (c-a));
        1: 1624:            }
        -: 1625:            else
        -: 1626:            {
        -: 1627:                tmp = (tmp >> (a-c));
        2: 1628:            }
        2: 1629:        }
        -: 1630:    }
        1: 1631:    else
        -: 1632:    {
        -: 1633:        if(((b-a)>31) || ((c-a)>31) || ((b-c)>31))
        -: 1634:        {
        1: 1635:          tmp = MAX32;
        -: 1636:        }
        -: 1637:        else
        -: 1638:        {
        -: 1639:            tmp = (1 << (b-a)) * x + y;
        -: 1640:            if(c>=b)
        4: 1641:            {
        -: 1642:               tmp = (tmp << (c-b));
        1: 1643:            }
        -: 1644:            else
        -: 1645:            {
        -: 1646:                tmp = (tmp >> (b-c));
        3: 1647:            }
        3: 1648:        }
        -: 1649:    }
        2: 1650:
        -: 1651:    
        -: 1652:    if(tmp >= MAX32)
        -: 1653:        {
        1: 1654:            tmp = MAX32;
        -: 1655:        }
        -: 1656:        else if (tmp <= MIN32)
        -: 1657:        {
        -: 1658:            tmp = MIN32;
        -: 1659:        }
        7: 1660:        return (sint32)tmp;
        -: 1661:}
        2: 1662:uint32 Mfx_AddP2_u32u32_u32(uint32 x, uint32 y, sint32 a, sint32 b, sint32 c)
        -: 1663:{
        5: 1664:    uint64 tmp;
        -: 1665:    if(a>=b)
        1: 1666:    {
        -: 1667:        if(((a-b)>31) || ((c-b)>31) || ((a-c)>31))
        7: 1668:        {
        -: 1669:          tmp = UMAX32;
        -: 1670:        }
        7: 1671:        else
        -: 1672:        {
        -: 1673:            tmp = (1 << (a-b)) * y + x;
        7: 1674:            if(c>=a)
        -: 1675:            {
        4: 1676:               tmp= (tmp << (c-a));
        -: 1677:            }
        1: 1678:            else
        -: 1679:            {
        -: 1680:                tmp = (tmp >> (a-c));
        -: 1681:            }
        3: 1682:        }
        3: 1683:    }
        -: 1684:    else
        1: 1685:    {
        -: 1686:        if(((b-a)>31) || ((c-a)>31) || ((b-c)>31))
        -: 1687:        {
        -: 1688:          tmp =  UMAX32;
        2: 1689:        }
        -: 1690:        else
        -: 1691:        {
        -: 1692:            tmp = (1 << (b-a)) * x + y;
        -: 1693:            if(c>=b)
        -: 1694:            {
        3: 1695:                tmp = (tmp << (c-b));
        -: 1696:            }
        1: 1697:            else
        -: 1698:            {
        -: 1699:                tmp = (tmp >> (b-c));
        -: 1700:            }
        2: 1701:        }
        2: 1702:    }
        -: 1703:
        1: 1704:
        -: 1705:    if(tmp >= UMAX32)
        -: 1706:        {
        -: 1707:            tmp = UMAX32;
        1: 1708:        }
        -: 1709:        else if (tmp <= UMIN32)
        -: 1710:        {
        -: 1711:            tmp = UMIN32;
        -: 1712:        }
        -: 1713:        return (uint32)tmp;
        7: 1714:
        -: 1715:}
        2: 1716:
        -: 1717:
        5: 1718:/**
        -: 1719:  @brief 16-Bit Subtraction of 2n Scaled Integer
        1: 1720:The routine subtracts two 16-bit integers with scaling factors set by input parameters.
        -: 1721:  Project element: [SWS_Mfx_00164] & [SWS_Mfx_00165] & [SWS_Mfx_00166] & [SWS_Mfx_00167] &  [SWS_Mfx_00168 Function ID: 0x1C1  & 0x1C8 ]
        7: 1722:*/
        -: 1723:
        -: 1724:sint16 Mfx_SubP2_s16s16_s16(sint16 x, sint16 y, sint16 a, sint16 b, sint16 c)
        -: 1725:{
        -: 1726:    sint32 tmp;
        -: 1727:    if(a>=b)
        -: 1728:    {
        -: 1729:        if(((a-b)>15) || ((c-b)>15) || ((a-c)>15))
        -: 1730:        {
        -: 1731:          tmp = MAX16;
        -: 1732:        }
        7: 1733:        else
        -: 1734:        {
        -: 1735:            tmp = (1 << (a-b)) * y - x;
        7: 1736:            if(c>=a)
        -: 1737:            {
        4: 1738:                tmp = (tmp << (c-a));
        -: 1739:            }
        1: 1740:            else
        -: 1741:            {
        -: 1742:                tmp = (tmp >> (a-c));
        -: 1743:            }
        3: 1744:        }
        3: 1745:    }
        -: 1746:    else
        1: 1747:    {
        -: 1748:        if(((b-a)>15) || ((c-a)>15) || ((b-c)>15))
        -: 1749:        {
        -: 1750:          tmp = MAX16;
        2: 1751:        }
        -: 1752:        else
        -: 1753:        {
        -: 1754:            tmp = (1 << (b-a)) * x - y;
        -: 1755:            if(c>=b)
        -: 1756:            {
        3: 1757:               tmp = (tmp << (c-b));
        -: 1758:            }
        1: 1759:            else
        -: 1760:            {
        -: 1761:                tmp = (tmp >> (b-c));
        -: 1762:            }
        2: 1763:        }
        2: 1764:    }
        -: 1765:
        1: 1766:    
        -: 1767:    if(tmp >= MAX16)
        -: 1768:        {
        -: 1769:            tmp = MAX16;
        1: 1770:        }
        -: 1771:        else if (tmp <= MIN16)
        -: 1772:        {
        -: 1773:            tmp = MIN16;
        -: 1774:        }
        -: 1775:        return (sint16)tmp;
        7: 1776:}
        -: 1777:uint16 Mfx_SubP2_u16u16_u16(uint16 x, uint16 y, sint16 a, sint16 b, sint16 c)
        2: 1778:{
        -: 1779:    uint32 tmp;
        5: 1780:    if(a>=b)
        -: 1781:    {
        1: 1782:        if(((a-b)>15) || ((c-b)>15) || ((a-c)>15))
        -: 1783:        {
        7: 1784:          tmp = UMAX16;
        -: 1785:        }
        -: 1786:        else
        7: 1787:        {
        -: 1788:            tmp = (1 << (a-b)) * y - x;
        -: 1789:            if(c>=a)
        7: 1790:            {
        -: 1791:               tmp= (tmp << (c-a));
        3: 1792:            }
        -: 1793:            else
        1: 1794:            {
        -: 1795:                tmp = (tmp >> (a-c));
        -: 1796:            }
        -: 1797:        }
        2: 1798:    }
        2: 1799:    else
        -: 1800:    {
        1: 1801:        if(((b-a)>15) || ((c-a)>15) || ((b-c)>15))
        -: 1802:        {
        -: 1803:          tmp =  UMAX16;
        -: 1804:        }
        1: 1805:        else
        -: 1806:        {
        -: 1807:            tmp = (1 << (b-a)) * x - y;
        -: 1808:            if(c>=b)
        -: 1809:            {
        -: 1810:                tmp = (tmp << (c-b));
        4: 1811:            }
        -: 1812:            else
        1: 1813:            {
        -: 1814:                tmp = (tmp >> (b-c));
        -: 1815:            }
        -: 1816:        }
        3: 1817:    }
        3: 1818:
        -: 1819:
        2: 1820:    if(tmp >= UMAX16)
        -: 1821:        {
        -: 1822:            tmp = UMAX16;
        -: 1823:        }
        1: 1824:        else if (tmp <= UMIN16)
        -: 1825:        {
        -: 1826:            tmp = UMIN16;
        -: 1827:        }
        -: 1828:        return (uint16)tmp;
        -: 1829:
        7: 1830:}
        -: 1831:
        2: 1832:
        -: 1833:/**
        5: 1834:  @brief 32-Bit Subtraction of 2n Scaled Integer
        -: 1835:The routine subtracts two 32-bit integers with scaling factors set by input parameters
        3: 1836:  Project element: [SWS_Mfx_00170] & [SWS_Mfx_00171] & [SWS_Mfx_00172] & [SWS_Mfx_00173] &  [SWS_Mfx_00174 Function ID: 0x1C9  & 0x1D0 ]
        -: 1837:*/
        7: 1838:
        -: 1839:sint32 Mfx_SubP2_s32s32_s32(sint32 x, sint32 y, sint32 a, sint32 b, sint32 c)
        -: 1840:{
        -: 1841:    sint64 tmp;
        -: 1842:    if(a>=b)
        -: 1843:    {
        -: 1844:        if(((a-b)>31) || ((c-b)>31) || ((a-c)>31))
        -: 1845:        {
        -: 1846:          tmp = MAX32;
        -: 1847:        }
        -: 1848:        else
        7: 1849:        {
        -: 1850:            tmp = (1 << (a-b)) * y - x;
        -: 1851:            if(c>=a)
        -: 1852:            {
        7: 1853:                tmp = (tmp << (c-a));
        -: 1854:            }
        3: 1855:            else
        -: 1856:            {
        1: 1857:                tmp = (tmp >> (a-c));
        -: 1858:            }
        -: 1859:        }
        -: 1860:    }
        2: 1861:    else
        2: 1862:    {
        -: 1863:        if(((b-a)>31) || ((c-a)>31) || ((b-c)>31))
        1: 1864:        {
        -: 1865:          tmp = MAX32;
        -: 1866:        }
        -: 1867:        else
        1: 1868:        {
        -: 1869:            tmp = (1 << (b-a)) * x - y;
        -: 1870:            if(c>=b)
        -: 1871:            {
        -: 1872:               tmp = (tmp << (c-b));
        -: 1873:            }
        4: 1874:            else
        -: 1875:            {
        1: 1876:                tmp = (tmp >> (b-c));
        -: 1877:            }
        -: 1878:        }
        -: 1879:    }
        3: 1880:
        3: 1881:    
        -: 1882:    if(tmp >= MAX32)
        2: 1883:        {
        -: 1884:            tmp = MAX32;
        -: 1885:        }
        -: 1886:        else if (tmp <= MIN32)
        1: 1887:        {
        -: 1888:            tmp = MIN32;
        -: 1889:        }
        -: 1890:        return (sint32)tmp;
        -: 1891:}
        -: 1892:uint32 Mfx_SubP2_u32u32_u32(uint32 x, uint32 y, sint32 a, sint32 b, sint32 c)
        7: 1893:{
        -: 1894:    uint64 tmp;
        2: 1895:    if(a>=b)
        -: 1896:    {
        5: 1897:        if(((a-b)>31) || ((c-b)>31) || ((a-c)>31))
        -: 1898:        {
        1: 1899:          tmp = UMAX32;
        -: 1900:        }
        7: 1901:        else
        -: 1902:        {
        -: 1903:            tmp = (1 << (a-b)) * y - x;
        7: 1904:            if(c>=a)
        -: 1905:            {
        -: 1906:               tmp= (tmp << (c-a));
        7: 1907:            }
        -: 1908:            else
        3: 1909:            {
        -: 1910:                tmp = (tmp >> (a-c));
        1: 1911:            }
        -: 1912:        }
        -: 1913:    }
        -: 1914:    else
        2: 1915:    {
        2: 1916:        if(((b-a)>31) || ((c-a)>31) || ((b-c)>31))
        -: 1917:        {
        1: 1918:          tmp =  UMAX32;
        -: 1919:        }
        -: 1920:        else
        -: 1921:        {
        1: 1922:            tmp = (1 << (b-a)) * x - y;
        -: 1923:            if(c>=b)
        -: 1924:            {
        -: 1925:                tmp = (tmp << (c-b));
        -: 1926:            }
        -: 1927:            else
        4: 1928:            {
        -: 1929:                tmp = (tmp >> (b-c));
        1: 1930:            }
        -: 1931:        }
        -: 1932:    }
        -: 1933:
        3: 1934:
        3: 1935:    if(tmp >= UMAX32)
        -: 1936:        {
        2: 1937:            tmp = UMAX32;
        -: 1938:        }
        -: 1939:        else if (tmp <= UMIN32)
        -: 1940:        {
        1: 1941:            tmp = UMIN32;
        -: 1942:        }
        -: 1943:        return (uint32)tmp;
        -: 1944:}
        -: 1945:
        -: 1946:
        7: 1947:/**
        -: 1948:  @brief Absolute Difference of 2n Scaled Integer
        2: 1949:The routine subtracts and takes the absolute value of two 16-bit integers with scaling factors set by input parameters.
        -: 1950:  Project element: [SWS_Mfx_00176] & [SWS_Mfx_00177] & [SWS_Mfx_00178] & [SWS_Mfx_00179] &  [SWS_Mfx_00180 Function ID: 0x1D1  & 0x1D6 ]
        5: 1951:*/
        -: 1952:
        3: 1953:sint16 Mfx_AbsDiffP2_s16s16_s16(sint16 x, sint16 y, sint16 a, sint16 b, sint16 c)
        -: 1954:{
        7: 1955:    sint32 tmp;
        -: 1956:    if(a>=b)
        -: 1957:    {
        -: 1958:        if(((a-b)>15) || ((c-b)>15) || ((a-c)>15))
        -: 1959:        {
        -: 1960:          tmp = MAX16;
        -: 1961:        }
        -: 1962:        else
        -: 1963:        {
        -: 1964:            tmp =Mfx_AbsDiff_s32s32_s32((1 << (a-b)) * y, x);
        6: 1965:            if(c>=a)
        -: 1966:            {
        -: 1967:                tmp = (tmp << (c-a));
        6: 1968:            }
        -: 1969:            else
        3: 1970:            {
        -: 1971:                tmp = (tmp >> (a-c));
        1: 1972:            }
        -: 1973:        }
        -: 1974:    }
        -: 1975:    else
        2: 1976:    {
        2: 1977:        if(((b-a)>15) || ((c-a)>15) || ((b-c)>15))
        -: 1978:        {
        1: 1979:          tmp = MAX16;
        -: 1980:        }
        -: 1981:        else
        -: 1982:        {
        1: 1983:            tmp =Mfx_AbsDiff_s32s32_s32((1 << (b-a)) * x, y);
        -: 1984:            if(c>=b)
        -: 1985:            {
        -: 1986:               tmp = (tmp << (c-b));
        -: 1987:            }
        -: 1988:            else
        3: 1989:            {
        -: 1990:                tmp = (tmp >> (b-c));
        1: 1991:            }
        -: 1992:        }
        -: 1993:    }
        -: 1994:
        2: 1995:    
        2: 1996:    if(tmp >= MAX16)
        -: 1997:        {
        1: 1998:            tmp = MAX16;
        -: 1999:        }
        -: 2000:        return (sint16)tmp;
        -: 2001:}
        1: 2002:uint16 Mfx_AbsDiffP2_u16u16_u16(uint16 x, uint16 y, sint16 a, sint16 b, sint16 c)
        -: 2003:{
        -: 2004:    uint32 tmp;
        -: 2005:    if(a>=b)
        -: 2006:    {
        -: 2007:        if(((a-b)>15) || ((c-b)>15) || ((a-c)>15))
        6: 2008:        {
        -: 2009:          tmp = UMAX16;
        2: 2010:        }
        -: 2011:        else
        6: 2012:        {
        -: 2013:            tmp =Mfx_AbsDiff_u32u32_u32((1 << (a-b)) * y, x);
        -: 2014:            if(c>=a)
        6: 2015:            {
        -: 2016:               tmp= (tmp << (c-a));
        -: 2017:            }
        6: 2018:            else
        -: 2019:            {
        3: 2020:                tmp = (tmp >> (a-c));
        -: 2021:            }
        1: 2022:        }
        -: 2023:    }
        -: 2024:    else
        -: 2025:    {
        2: 2026:        if(((b-a)>15) || ((c-a)>15) || ((b-c)>15))
        2: 2027:        {
        -: 2028:          tmp =  UMAX16;
        1: 2029:        }
        -: 2030:        else
        -: 2031:        {
        -: 2032:            tmp =Mfx_AbsDiff_u32u32_u32((1 << (b-a)) * x, y);
        1: 2033:            if(c>=b)
        -: 2034:            {
        -: 2035:                tmp = (tmp << (c-b));
        -: 2036:            }
        -: 2037:            else
        -: 2038:            {
        3: 2039:                tmp = (tmp >> (b-c));
        -: 2040:            }
        1: 2041:        }
        -: 2042:    }
        -: 2043:
        -: 2044:
        2: 2045:    if(tmp >= UMAX16)
        2: 2046:        {
        -: 2047:            tmp = UMAX16;
        1: 2048:        }
        -: 2049:
        -: 2050:        return (uint16)tmp;
        -: 2051:
        1: 2052:}
        -: 2053:
        -: 2054:/**
        -: 2055:  @brief  16-Bit Absolute Value of 2n Scaled Integer
        -: 2056:The routine takes the absolute value of a 16-bit integer with scaling factors set by input
        -: 2057:parameters.
        6: 2058:  Project element: [SWS_Mfx_00182] & [SWS_Mfx_00183] & [SWS_Mfx_00184] & [SWS_Mfx_00185] &  [SWS_Mfx_00186 Function ID: 0x1D7  & 0x1D8 ]
        -: 2059:*/
        2: 2060:sint16 Mfx_AbsP2_s16_s16(sint16 x, sint16 a, sint16 c)
        -: 2061:{
        -: 2062:    sint32 tmp;
        6: 2063:
        -: 2064:        if((c-a)<-15)
        -: 2065:        {
        -: 2066:          tmp = MIN16;
        -: 2067:        }
        -: 2068:        else if((c-a)>15)
        -: 2069:        {
        -: 2070:          tmp = MAX16;
        -: 2071:        }
        -: 2072:        else
        -: 2073:        {
        4: 2074:            tmp = (sint32)Mfx_Abs_s16_s16(x);
        -: 2075:            if(c-a>=0)
        -: 2076:            {
        -: 2077:                tmp = (tmp << (c-a));
        4: 2078:            }
        -: 2079:            else
        1: 2080:            {
        -: 2081:                tmp = (tmp >> (a-c));
        3: 2082:            }
        -: 2083:        }
        1: 2084:
        -: 2085:        if(tmp >= MAX16)
        -: 2086:        {
        -: 2087:            tmp = MAX16;
        2: 2088:        }
        2: 2089:        else if (tmp <= MIN16)
        -: 2090:        {
        1: 2091:            tmp = MIN16;
        -: 2092:        }
        -: 2093:        return (sint16)tmp;
        -: 2094:}
        1: 2095:
        -: 2096:uint16 Mfx_AbsP2_s16_u16(sint16 x, sint16 a, sint16 c){
        -: 2097:    uint32 tmp;
        -: 2098:
        4: 2099:        if((c-a)<-15)
        -: 2100:        {
        1: 2101:          tmp = UMIN16;
        -: 2102:        }
        3: 2103:        else if((c-a)>15)
        -: 2104:        {
        1: 2105:          tmp = UMAX16;
        -: 2106:        }
        4: 2107:        else
        -: 2108:        {
        -: 2109:            tmp =(uint32)Mfx_Abs_s16_s16(x);
        4: 2110:            if(c-a>=0)
        -: 2111:            {
        -: 2112:                tmp = (tmp << (c-a));
        -: 2113:            }
        4: 2114:            else
        -: 2115:            {
        1: 2116:                tmp = (tmp >> (a-c));
        -: 2117:            }
        3: 2118:        }
        -: 2119:
        1: 2120:        if(tmp >= UMAX16)
        -: 2121:        {
        -: 2122:            tmp = UMAX16;
        -: 2123:        }
        2: 2124:        else if (tmp <= UMIN16)
        2: 2125:        {
        -: 2126:            tmp = UMIN16;
        1: 2127:        }
        -: 2128:        return (uint16)tmp;
        -: 2129:}
        -: 2130:
        1: 2131:
        -: 2132:/**
        -: 2133:  @brief  32-Bit Absolute Value of 2n Scaled Integer
        -: 2134:The routine takes the absolute value of a 16-bit integer with scaling factors set by input
        4: 2135:parameters.
        -: 2136:  Project element: [SWS_Mfx_00188] & [SWS_Mfx_00189] & [SWS_Mfx_00190] & [SWS_Mfx_00191] &  [SWS_Mfx_00192 Function ID: 0x1D9  & 0x1DA ]
        1: 2137:*/
        -: 2138:sint32 Mfx_AbsP2_s32_s32(sint32 x, sint16 a, sint16 c)
        3: 2139:{
        -: 2140:    sint64 tmp;
        2: 2141:
        -: 2142:        if((c-a)<-31)
        4: 2143:        {
        -: 2144:          tmp = MIN32;
        -: 2145:        }
        -: 2146:        else if((c-a)>31)
        -: 2147:        {
        -: 2148:          tmp = MAX32;
        -: 2149:        }
        -: 2150:        else
        -: 2151:        {
        -: 2152:            tmp = (sint64)Mfx_Abs_s32_s32(x);
        -: 2153:            if(c-a>=0)
        4: 2154:            {
        -: 2155:                tmp = (tmp << (c-a));
        -: 2156:            }
        -: 2157:            else
        4: 2158:            {
        -: 2159:                tmp = (tmp >> (a-c));
        1: 2160:            }
        -: 2161:        }
        3: 2162:
        -: 2163:        if(tmp >= MAX32)
        1: 2164:        {
        -: 2165:            tmp = MAX32;
        -: 2166:        }
        -: 2167:        else if (tmp <= MIN32)
        2: 2168:        {
        2: 2169:            tmp = MIN32;
        -: 2170:        }
        1: 2171:        return (sint32)tmp;
        -: 2172:}
        -: 2173:
        -: 2174:uint32 Mfx_AbsP2_s32_u32(sint32 x, sint16 a, sint16 c){
        1: 2175:    uint64 tmp;
        -: 2176:
        -: 2177:        if((c-a)<-31)
        -: 2178:        {
        4: 2179:          tmp = UMIN32;
        -: 2180:        }
        1: 2181:        else if((c-a)>31)
        -: 2182:        {
        3: 2183:          tmp = UMAX32;
        -: 2184:        }
        1: 2185:        else
        -: 2186:        {
        4: 2187:            tmp =(uint64)Mfx_Abs_s32_s32(x);
        -: 2188:            if(c-a>=0)
        -: 2189:            {
        4: 2190:                tmp = (tmp << (c-a));
        -: 2191:            }
        -: 2192:            else
        -: 2193:            {
        4: 2194:                tmp = (tmp >> (a-c));
        -: 2195:            }
        1: 2196:        }
        -: 2197:
        3: 2198:        if(tmp >= UMAX32)
        -: 2199:        {
        1: 2200:            tmp = UMAX32;
        -: 2201:        }
        -: 2202:        else if (tmp <= UMIN32)
        -: 2203:        {
        2: 2204:            tmp = UMIN32;
        2: 2205:        }
        -: 2206:        return (uint32)tmp;
        1: 2207:}
